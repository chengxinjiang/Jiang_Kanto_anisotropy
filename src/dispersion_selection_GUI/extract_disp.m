clear;
close all;

%% to use this GUI, one needs to get the phase diagram (generated by the script)
%% into mat format. 
%% by Chengxin Jiang @Harvard (Mar2019)


%% define data vectors

% criteria for data selection
para.nseg = 5;
para.ccrt = 0.1;
para.mamp = 0.95;

%% load data
tmpz = dir('ZZ/*.mat');
tmpr = dir('RR/*.mat');
tmpt = dir('TT/*.mat');
nfiles = length(tmpz);

% loop through all files
for ii=1:nfiles
    
    % check the consistency of z and r file
    if ~strcmpi(tmpz(ii).name,tmpr(ii).name)
        fprintf('z %s and r %s not consisent\n',tmpz(ii).name,tmpr(ii),name);
        exit;
    end
        
    tname1 = sprintf('%s/%s',tmpz(ii).folder,tmpz(ii).name);
    tname2 = sprintf('%s/%s',tmpr(ii).folder,tmpr(ii).name);
    tname3 = sprintf('%s/%s',tmpz(ii).folder,tmpz(ii).name);
    % load file
    zfile = load(tname1);
    rfile = load(tname2);
    tfile = load(tname3)
    ttemp = split(tmpz(ii).name,'.');
    sta   = ttemp(1);

    % plot the ZZ, RR and TT on first row for reference
    figure('Position',[100,100,2400,1200]);cla
    subplot(231);
    imagesc(zfile.per,zfile.vel,zfile.data);
    colormap(jet);
    set(gca,'Ydir','normal')
    xlabel('Period [s]');
    ylabel('C [km/s]');
    title([sta,' ZZ']);
    subplot(232);
    imagesc(rfile.per,rfile.vel,rfile.data);
    colormap(jet);
    set(gca,'Ydir','normal')
    xlabel('Period [s]');
    ylabel('C [km/s]');
    title([sta,' RR']);
    subplot(233);
    imagesc(tfile.per,tfile.vel,tfile.data);
    colormap(jet);
    set(gca,'Ydir','normal')
    xlabel('Period [s]');
    ylabel('C [km/s]');
    title([sta,' ZZ+RR']);

    [sper1,svel1,sun1] = get_maximum_amp(zfile,para);

    % only the Z component
    subplot(234)
    imagesc(zfile.per,zfile.vel,zfile.data);
    colormap(jet);
    set(gca,'Ydir','normal')
    xlabel('Period [s]');
    ylabel('C [km/s]');
    title([sta,' ZZ']);
    hold on;
    errorbar(sper1,svel1,sun1,'k--o','MarkerSize',8);

    % select ZZ data using GUI
    [~,~,~] = selectdata(sta,sun1,'Verify','on');
    
    % only the R component
    [sper2,svel2,sun2] = get_maximum_amp(rfile,para);
    subplot(235);
    imagesc(rfile.per,rfile.vel,rfile.data);
    colormap(jet);
    set(gca,'Ydir','normal')
    xlabel('Period [s]');
    ylabel('C [km/s]');
    title([sta,' RR']);
    hold on;
    errorbar(sper2,svel2,sun2,'k--o','MarkerSize',8);
    
    % select RR data using GUI
    [pl,xs,ys] = selectdata(sta,sun2,'Verify','on');

     % only the T component
    [sper3,svel3,sun3] = get_maximum_amp(tfile,para);
    subplot(235);
    imagesc(tfile.per,tfile.vel,tfile.data);
    colormap(jet);
    set(gca,'Ydir','normal')
    xlabel('Period [s]');
    ylabel('C [km/s]');
    title([sta,' TT']);
    hold on;
    errorbar(sper3,svel3,sun3,'k--o','MarkerSize',8);
    
    % select TT data using GUI
    [pl,xs,ys] = selectdata(sta,sun2,'Verify','on');
    clf;
    close;
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% subfunction to extract max amplitude %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [per,vel,un] = get_maximum_amp(sta,para)
    % find the global maximum at each period from the 2D array representing
    % the amplitude of FK transform
    
    % define vectors
    pp = sta.per;
    cc = sta.vel;
    ncc = length(cc);
    dc  = abs(cc(1)-cc(2));
    data = sta.data;
    nper = length(pp);
    nseg = para.nseg;
    ccrt = para.ccrt;

    % initalize array
    disp = zeros(nper,1);
    indx = zeros(nper,1);

    % find the local maximum
    for ii=1:nper
        [~,ind] = max(data(:,ii));
        indx(ii) = ind;
        disp(ii) = cc(ind);
    end

    tindx = zeros(nper,1);
    unc   = zeros(nper,1);
    
    % remove isolated points
    for ii = nseg:nper-nseg
        
        ind1 = 0; ind2 = 0;
        % keep it if adjacent points are continous
        if abs(disp(ii)-disp(ii-1))<=ccrt && abs(disp(ii)-disp(ii+1))<=ccrt
            tindx(ii) = ii;
            
            % estimate unc based on amp width
            for jj = indx(ii):-1:1
                if data(jj,ii) <= para.mamp
                    ind1 = jj;
                    break;
                end
            end
               
            % the right hand side
            for jj = indx(ii):1:ncc
                if data(jj,ii) <= para.mamp
                    ind2 = jj;
                    break;
                end
            end
            
            unc(ii) = abs(ind1-ind2)*dc;
                    
        end
    end

    % remove the bad ones
    ttindx = find(tindx>0);
    per = pp(ttindx);
    vel = disp(ttindx);
    un  = unc(ttindx);
end
